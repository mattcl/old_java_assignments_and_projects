/**
 * BulletWave.java
 */
package rampancy_old.util;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.*;

import rampancy_old.statistics.*;
import rampancy_old.util.tree.*;
import rampancy_old.weapons.FiringSolution;
import robocode.util.Utils;

/**
 * BulletWaves are waves generated by Durandal shooting at an enemy target
 * @author Matthew Chun-Lum
 *
 */
public class BulletWave extends Wave {
    public static Color DEFAULT_COLOR = Color.green;
    
    private EnemyRobot target;
    private EnemyState originState;
    private int[] originProfile;
    private double startBearing;
    private int direction;
    private double offsetAngle;
    private Segment segment;
    private boolean willDraw;
    private Point2D.Double anticipatedIntercept;
    
    
    public BulletWave(EnemyRobot target, Point2D.Double origin, long timeFired, FiringSolution firingSolution) {
        super(origin, timeFired + 1, firingSolution.power, firingSolution.color);
        this.originState = firingSolution.enemyState;
        this.originProfile = target.getVariationProfile().getProfile(); // direct pointer
        this.target = target;
        this.startBearing = target.getAbsoluteBearing();
        this.direction = target.getDirectionTraveling();
        this.willDraw = false;
        this.segment = firingSolution.segment;
        if(firingSolution.anticipated != null)
            this.anticipatedIntercept = firingSolution.anticipated;
    }
    
    /**
     * Determines if this wave has hit a target
     * @param target
     * @param time
     * @return
     */
    public boolean checkHit(long time) {
        update(time);
        if(origin.distance(target.getLocation()) <= distanceTraveled) {
            double desiredDirection = Util.computeAbsoluteBearing(origin, target.getLastLocation());
            double angleOffset = Utils.normalRelativeAngle(desiredDirection - startBearing);
            double guessFactor = Math.max(-1, Math.min(1, angleOffset / Util.computeMaxEscapeAngle(getVelocity()))) * direction;
            if(segment != null)
                updateSegment(guessFactor);
            return true;
        }
        return false;
    }
    
    /*
     * Updates the segment with the current guess factor
     */
    private void updateSegment(double guessFactor) {
        // if the segment branches before we can update the GF array, find
        // the current leaf
        
        if(segment.hasBranched)
            segment = segment.getSegment(originState, originProfile);

        if(segment != null)
            segment.updateGuessFactors(guessFactor, !willDraw);
        else
            System.out.println("Segment is null");
    }
    
    /**
     * Sets the offsetAngle
     * @param angle
     */
    public void setOffsetAngle(double angle) {
        offsetAngle = angle;
    }
    
    /**
     * @return the offsetAngle
     */
    public double getOffsetAngle() {
        return offsetAngle;
    }
    
    /**
     * @return the target of this wave
     */
    public EnemyRobot getTarget() {
        return target;
    }
    
    /**
     * @return the direction
     */
    public int getDirection() {
        return direction;
    }
    
    public void setWillDraw(boolean val) {
        willDraw = val;
    }
    
    public Color getColor() {
        return color;
    }
    
    /* (non-Javadoc)
     * @see rampancy.util.Wave#draw(java.awt.Graphics2D)
     */
    public void draw(Graphics2D g) {
        if(willDraw) {
            super.draw(g);
            if(anticipatedIntercept != null) {
                g.setColor(Color.PINK);
                g.fillOval((int) anticipatedIntercept.x, 
                           (int) anticipatedIntercept.y, 20, 20) ;
            }
        }
    }
}
